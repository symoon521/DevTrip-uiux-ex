

# **도커(Docker) 기술 완벽 가이드: 개념부터 프로덕션까지**

## **파트 1: 도커 패러다임: 근본적인 이해**

현대 소프트웨어 개발 환경은 복잡성과 비일관성이라는 고질적인 문제에 직면해 있습니다. 이러한 문제를 해결하기 위해 등장한 도커(Docker)는 애플리케이션의 개발, 배포, 실행 방식을 근본적으로 바꾸어 놓았습니다. 이 파트에서는 도커의 핵심 철학, 아키텍처, 그리고 현대 개발 워크플로에서 도커가 차지하는 중요한 위치를 심도 있게 탐구합니다.

### **섹션 1.1: 도커란 무엇인가? 컨테이너화의 재구성**

#### **핵심 정의**

도커는 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 개방형 소프트웨어 플랫폼입니다.1 애플리케이션을 실행하는 데 필요한 모든 요소, 즉 코드, 런타임, 시스템 도구, 라이브러리 및 기타 종속성을 '컨테이너(Container)'라는 표준화된 유닛으로 패키징합니다.1 2013년 솔로몬 하이크(Solomon Hykes)에 의해 처음 소개된 이 기술은 Go 언어로 개발되었으며, 컨테이너 기반 가상화 기술을 통해 어떤 환경에서든 애플리케이션을 안정적으로 실행할 수 있도록 설계되었습니다.2

#### **"환경 불일치" 문제의 해결**

도커가 해결하고자 하는 가장 근본적인 문제는 "내 컴퓨터에서는 잘 되는데..."로 요약되는 '환경 불일치(Environment Disparity)' 문제입니다.2 개발 환경, 테스트 환경, 운영 환경이 각각 미묘하게 다르기 때문에 발생하는 예측 불가능한 오류와 배포 실패는 오랫동안 개발자들의 골칫거리였습니다. 예를 들어, 로컬 Windows 환경에서 개발한 애플리케이션이 운영 서버인 Linux 환경에서 제대로 동작하지 않는 경우가 비일비재했습니다.2

도커는 애플리케이션 코드뿐만 아니라, 해당 코드가 실행되는 환경 자체를 이미지로 만들어 이 문제를 해결합니다. Dockerfile이라는 설정 파일에 운영체제, 시스템 변수, 설치된 패키지 등 전체 실행 환경을 코드로 명시하여 패키징하므로, 개발부터 운영까지 모든 단계에서 완벽하게 동일한 환경을 보장할 수 있습니다.2

#### **주요 이점**

이러한 접근 방식은 다음과 같은 강력한 이점을 제공합니다.

* **구성 단순화 및 신속한 배포:** 모든 플랫폼에서 동일하게 실행 가능한 환경을 Dockerfile 하나로 정의하고 전달할 수 있어 구성이 매우 단순해집니다.2 컨테이너는 운영체제(OS)를 부팅할 필요 없이 애플리케이션 프로세스만 실행하므로 수 초 내에 신속하게 생성 및 배포가 가능합니다.1  
* **개발 생산성 향상:** 개발자는 더 이상 복잡한 환경 설정에 시간을 낭비하지 않고 코드에만 집중할 수 있습니다. 예를 들어, 공유 볼륨(Shared Volume) 기능을 사용하면 Windows 로컬 환경의 편집기로 소스 코드를 수정하는 즉시 Linux 환경의 도커 컨테이너 내에서 변경 사항이 반영되어 업무 효율이 극대화됩니다.2  
* **애플리케이션 격리:** 각 컨테이너는 호스트 OS 및 다른 컨테이너와 독립된 공간에서 실행됩니다. 이는 각기 다른 라이브러리 버전을 요구하는 애플리케이션들이 서로 충돌 없이 동일한 호스트에서 공존할 수 있게 합니다.2 예를 들어, 웹 서버와 여러 API 서버를 각각 다른 컨테이너에서 실행하여 논리적으로 완벽하게 분리할 수 있습니다.2  
* **이식성:** 도커 컨테이너는 도커 엔진이 설치된 곳이라면 어디서든 안정적으로 실행됩니다. 로컬 개발 시스템에서 AWS와 같은 클라우드 프로덕션 환경으로 애플리케이션을 원활하게 이전할 수 있으며, "한 번 빌드하면 어디서든 실행된다(Build once, run anywhere)"는 이상을 실현합니다.1

### **섹션 1.2: 컨테이너 vs. 가상 머신: 명확한 비교**

도커 컨테이너는 가상화 기술의 한 형태이지만, 전통적인 가상 머신(Virtual Machine, VM)과는 근본적인 아키텍처 차이를 보입니다. 이 차이를 이해하는 것은 도커의 효율성과 가치를 파악하는 데 매우 중요합니다.

#### **아키텍처의 차이**

가장 핵심적인 차이는 추상화하는 계층에 있습니다.

* **가상 머신 (VM):** VM은 하드웨어를 가상화합니다. 호스트 운영체제(Host OS) 위에서 하이퍼바이저(Hypervisor)라는 소프트웨어가 실행되며, 이 하이퍼바이저는 여러 개의 가상 하드웨어 스택을 생성합니다. 각 VM은 이 가상 하드웨어 위에 완전한 게스트 운영체제(Guest OS)를 설치하고, 그 위에서 애플리케이션을 실행합니다.2 이 구조 때문에 VM은 각각 독립된 OS 커널을 가지며, 하드웨어 수준에서 격리됩니다.11  
* **도커 컨테이너:** 컨테이너는 운영체제를 가상화합니다. 호스트 OS 위에 도커 엔진이 설치되고, 모든 컨테이너는 호스트 OS의 커널을 공유합니다.5 컨테이너는 애플리케이션과 그 실행에 필요한 바이너리 및 라이브러리(Bin/Libs)만을 패키징합니다. 즉, 컨테이너에는 게스트 OS가 포함되지 않습니다.2

#### **리소스 효율성**

이러한 아키텍처의 차이는 리소스 사용량에 직접적인 영향을 미칩니다. VM은 완전한 OS를 포함하기 때문에 용량이 수십 GB에 달하고, 부팅하는 데 수 분이 소요되며, 상당한 양의 CPU와 메모리를 점유합니다.2 반면, 컨테이너는 필요한 파일만 포함하므로 용량이 수십 MB 수준으로 매우 작고, OS 부팅 과정이 없어 수 초 내에 시작됩니다.9 결과적으로, 동일한 물리적 서버에서 VM보다 훨씬 더 많은 수의 컨테이너를 실행할 수 있어 서버 활용률을 극대화하고 운영 비용을 절감할 수 있습니다.1

#### **보안적 관점**

격리 수준에서는 VM이 더 강력한 보안을 제공합니다. VM은 하이퍼바이저를 통해 하드웨어 수준에서 완벽하게 분리되므로, 하나의 VM에서 발생한 보안 문제가 다른 VM이나 호스트 시스템에 영향을 미칠 가능성이 매우 낮습니다.11 반면, 컨테이너는 호스트의 커널을 공유하기 때문에 커널 수준의 취약점이 발견될 경우, 해당 호스트에서 실행 중인 모든 컨테이너가 위험에 노출될 수 있습니다.11

#### **사용 사례 적합성**

따라서 어떤 기술을 선택할지는 특정 요구사항에 따라 달라집니다.

* **가상 머신(VM)이 적합한 경우:**  
  * 하나의 물리적 서버에서 여러 개의 서로 다른 운영체제(예: Linux와 Windows)를 실행해야 할 때.11  
  * 최고 수준의 보안 격리가 필수적인 민감한 워크로드를 다룰 때.16  
* **도커 컨테이너가 적합한 경우:**  
  * 하나의 애플리케이션을 여러 인스턴스로 빠르게 확장(scale-out)해야 할 때.11  
  * 마이크로서비스 아키텍처(MSA)를 구현하여 각 서비스를 독립적으로 개발, 배포, 확장하고자 할 때.1  
  * 개발, 테스트, 운영 환경의 일관성을 유지하여 배포 속도와 안정성을 높이고자 할 때.16

| 기능 | 도커 컨테이너 | 가상 머신 (VM) |
| :---- | :---- | :---- |
| **추상화 계층** | 운영체제 (OS) | 하드웨어 |
| **크기** | 작음 (수십 MB) | 큼 (수십 GB) |
| **시작 시간** | 빠름 (수 초) | 느림 (수 분) |
| **성능** | 네이티브에 가까움 | 하이퍼바이저 오버헤드 존재 |
| **리소스 오버헤드** | 낮음 (Guest OS 없음) | 높음 (Guest OS 필요) |
| **보안 격리** | 프로세스 수준 격리 (커널 공유) | 완벽한 격리 (커널 분리) |
| **이식성** | 높음 (도커 엔진만 있으면 됨) | 낮음 (OS 이미지 전체 이동) |
| **OS 의존성** | 호스트 OS 커널에 의존 | 호스트 OS와 무관 |

### **섹션 1.3: 도커 생태계: 핵심 구성 요소 해부**

도커의 강력함은 단순히 컨테이너 기술 자체에만 있는 것이 아닙니다. 컨테이너를 생성, 관리, 배포하는 일련의 과정을 지원하는 잘 정의된 생태계가 그 핵심입니다. 도커의 작동 방식을 이해하려면 이 생태계를 구성하는 핵심 요소들을 알아야 합니다.

* **도커 엔진 (Docker Engine):** 도커의 심장부 역할을 하는 클라이언트-서버 애플리케이션입니다.6 서버 역할을 하는  
  **도커 데몬(dockerd)**, 데몬과 통신하기 위한 **REST API**, 그리고 사용자가 이 API와 상호작용할 수 있도록 하는 \*\*명령줄 인터페이스(CLI) 클라이언트(docker)\*\*로 구성됩니다.18 데몬은 이미지, 컨테이너, 네트워크, 볼륨과 같은 모든 도커 객체의 생성과 관리를 총괄합니다.  
* **도커 이미지 (Docker Image):** 컨테이너를 생성하기 위한 읽기 전용 템플릿입니다.1 애플리케이션과 그 실행 환경에 필요한 모든 것(코드, 런타임, 라이브러리, 환경 변수, 설정 파일 등)을 담고 있는 "설계도" 또는 "스냅샷"에 비유할 수 있습니다.5 이미지는  
  Dockerfile로부터 빌드되며, 여러 개의 읽기 전용 레이어(layer)로 구성됩니다. 기존 이미지에 변경 사항이 생기면 새로운 레이어가 추가되는 방식으로 효율적인 저장과 전송이 가능합니다.4  
* **도커 컨테이너 (Docker Container):** 도커 이미지의 실행 가능한 인스턴스입니다.5 이미지가 "설계도"라면, 컨테이너는 그 설계도로 만들어진 "제품" 또는 "집"과 같습니다.4 컨테이너가 생성될 때, 이미지의 읽기 전용 레이어들 위에 쓰기 가능한 '컨테이너 레이어'가 추가됩니다. 실행 중인 컨테이너 내에서 발생하는 모든 변경 사항(파일 생성, 수정, 삭제 등)은 이 쓰기 가능한 레이어에 저장됩니다.4 이 구조 덕분에 하나의 이미지로부터 여러 개의 독립적인 컨테이너를 동시에 실행할 수 있습니다.23  
* **도커파일 (Dockerfile):** 도커 이미지를 자동으로 빌드하기 위한 명령어들을 담고 있는 텍스트 파일입니다.4  
  FROM, RUN, COPY와 같은 지시어를 순서대로 기술하여 이미지가 어떻게 구성되어야 하는지를 정의하는 "레시피"와 같습니다.22  
  Dockerfile을 사용하면 이미지 생성 과정을 코드로 관리할 수 있어, 재현 가능하고 일관된 빌드가 보장됩니다.  
* **도커 레지스트리 (Docker Registry) & 도커 허브 (Docker Hub):** 도커 이미지를 저장하고 배포하는 시스템입니다.17  
  **도커 허브**는 도커가 공식적으로 제공하는 기본 공개 레지스트리로, 수많은 공식 이미지와 커뮤니티가 만든 이미지를 보관하고 공유하는 거대한 라이브러리 역할을 합니다.6 기업이나 개인은 필요에 따라 비공개 레지스트리를 구축하여 사용할 수도 있습니다.

도커의 진정한 혁신은 컨테이너라는 격리 기술 자체를 넘어, 소프트웨어의 패키징과 배포에 대한 전체 워크플로를 표준화한 데 있습니다. Dockerfile로 환경을 코드로 정의하여 재현 가능한 빌드를 보장하고, 그 결과물인 이미지를 불변의 아티팩트로 만들어 관리하며, 레지스트리를 통해 이를 안정적으로 배포하는 이 일련의 과정이 바로 도커가 '환경 불일치' 문제를 근본적으로 해결하고 현대적인 CI/CD 및 데브옵스(DevOps) 문화를 가속화하는 핵심 원동력입니다. 따라서 도커를 도입한다는 것은 단순히 새로운 가상화 도구를 사용하는 것을 넘어, 소프트웨어를 만들고, 전달하고, 실행하는 방식에 대한 새로운 패러다임을 채택하는 것을 의미합니다.1

## **파트 2: 시작하기: 설치 및 첫걸음**

도커를 사용하기 위한 첫 단계는 자신의 운영체제에 맞는 도커 환경을 구축하는 것입니다. 이 파트에서는 Windows, macOS, Linux 각 환경에 도커를 설치하고, 정상적으로 작동하는지 확인하는 과정을 상세히 안내합니다.

### **섹션 2.1: Windows에 Docker Desktop 설치하기**

Windows 환경에서 도커를 사용하기 위해서는 Docker Desktop을 설치해야 합니다. 최신 버전의 Docker Desktop은 WSL 2(Windows Subsystem for Linux 2)를 백엔드로 사용하여 Linux 컨테이너에 대한 성능과 호환성을 크게 향상시켰습니다.

#### **사전 요구사항**

* **운영체제:** Windows 10 64비트(Pro, Enterprise, Education 22H2 이상) 또는 Windows 11 64비트.24  
* **하드웨어:** 4GB 이상의 시스템 RAM과 SLAT(Second Level Address Translation)을 지원하는 64비트 프로세서.24  
* **BIOS/UEFI 설정:** 하드웨어 가상화 기능이 활성화되어 있어야 합니다.24  
* **WSL 2 활성화:** Docker Desktop의 권장 백엔드인 WSL 2 기능이 활성화되어 있어야 합니다.

#### **설치 절차**

1. **WSL 2 활성화 및 업데이트:** 관리자 권한으로 PowerShell 또는 명령 프롬프트를 열고 다음 명령어를 실행하여 WSL 2를 설치하거나 최신 버전으로 업데이트합니다. 시스템 재시작이 필요할 수 있습니다.24  
   PowerShell  
   wsl \-\-install  
   wsl \-\-update

2. **Docker Desktop 다운로드:** Docker 공식 웹사이트에서 Windows용 Docker Desktop Installer.exe 파일을 다운로드합니다.25  
3. **설치 프로그램 실행:** 다운로드한 설치 파일을 더블클릭하여 실행합니다. 설치 과정 중 'Configuration' 페이지에서 'Use WSL 2 instead of Hyper-V' 옵션이 선택되었는지 확인합니다.24  
4. **설치 완료 및 실행:** 설치 마법사의 지시에 따라 설치를 완료합니다. 설치 후 Docker Desktop을 처음 실행하면 구독 서비스 계약에 동의해야 합니다.25 관리자 계정이 아닌 경우, 원활한 사용을 위해 현재 사용자 계정을  
   docker-users 그룹에 추가하는 것이 권장됩니다.24

### **섹션 2.2: macOS에 Docker Desktop 설치하기**

macOS에서도 Docker Desktop을 통해 도커를 손쉽게 사용할 수 있습니다.

#### **사전 요구사항**

* **운영체제:** 현재 및 이전 두 개의 주요 macOS 릴리스 버전.29  
* **하드웨어:** 4GB 이상의 RAM.29  
* **Apple Silicon (M1/M2/M3) Mac:** 일부 x86/amd64 아키텍처 기반의 CLI 도구를 실행하기 위해 Rosetta 2를 설치하는 것이 권장됩니다.29

#### **설치 방법**

* **공식 설치 프로그램 (권장):**  
  1. Docker 공식 웹사이트에서 자신의 Mac 칩셋(Apple Silicon 또는 Intel)에 맞는 .dmg 파일을 다운로드합니다.26  
  2. 다운로드한 .dmg 파일을 열고 Docker 아이콘을 'Applications' 폴더로 드래그하여 설치합니다.29  
  3. 'Applications' 폴더에서 Docker를 실행하고, 서비스 이용 약관에 동의합니다.29  
* Homebrew 사용:  
  터미널 사용에 익숙하다면 Homebrew를 통해 간단하게 설치할 수 있습니다.30  
  Bash  
  brew install \--cask docker

### **섹션 2.3: Linux (Ubuntu)에 Docker Engine 설치하기**

서버 환경에서 주로 사용되는 Linux에서는 핵심 서비스인 Docker Engine을 직접 설치하는 것이 일반적입니다. 여기서는 Ubuntu LTS 버전을 기준으로 apt 저장소를 이용한 설치 방법을 설명합니다.

#### **사전 요구사항**

* **운영체제:** 지원되는 Ubuntu 64비트 버전 (예: 22.04 LTS, 24.04 LTS).32

#### **설치 절차**

1. **apt 패키지 인덱스 업데이트 및 사전 패키지 설치:**  
   Bash  
   sudo apt-get update  
   sudo apt-get install ca-certificates curl

   32  
2. **Docker 공식 GPG 키 추가:** 패키지의 신뢰성을 보장하기 위해 Docker의 GPG 키를 시스템에 추가합니다.32  
   Bash  
   sudo install \-m 0755 \-d /etc/apt/keyrings  
   sudo curl \-fsSL https://download.docker.com/linux/ubuntu/gpg \-o /etc/apt/keyrings/docker.asc  
   sudo chmod a+r /etc/apt/keyrings/docker.asc

3. **Docker apt 저장소 설정:** apt가 Docker 패키지를 찾을 수 있도록 공식 저장소를 추가합니다.32  
   Bash  
   echo \\  
     "deb \[arch=$(dpkg \--print-architecture) signed-by=/etc/apt/keyrings/docker.asc\] https://download.docker.com/linux/ubuntu \\  
     $(. /etc/os-release && echo "$VERSION\_CODENAME") stable" | \\  
     sudo tee /etc/apt/sources.list.d/docker.list \> /dev/null

4. **Docker Engine 설치:** 저장소 설정 후, 패키지 인덱스를 다시 업데이트하고 Docker 관련 패키지들을 설치합니다.32  
   Bash  
   sudo apt-get update  
   sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

#### **설치 후 중요 설정**

1. **sudo 없이 Docker 명령어 사용하기:** 매번 sudo를 입력하는 불편함을 없애기 위해 현재 사용자를 docker 그룹에 추가합니다. 이 설정은 재로그인해야 적용됩니다.26  
   Bash  
   sudo usermod \-aG docker $USER  
   newgrp docker

2. **시스템 부팅 시 Docker 자동 시작 설정:** 서버 재부팅 시 Docker 데몬이 자동으로 실행되도록 서비스를 활성화합니다.26  
   Bash  
   sudo systemctl enable docker.service  
   sudo systemctl enable containerd.service

### **섹션 2.4: 설치 확인: hello-world 컨테이너 실행하기**

모든 운영체제에서 설치가 완료되면, 다음 명령어를 터미널에서 실행하여 도커가 정상적으로 작동하는지 확인할 수 있습니다.

#### **명령어 실행**

Bash

docker run hello-world

36

#### **출력 결과 분석**

이 간단한 명령어 뒤에서는 다음과 같은 복잡한 과정이 자동으로 수행됩니다 36:

1. **클라이언트에서 데몬으로 요청:** docker 클라이언트가 docker 데몬에게 hello-world 이미지를 실행하라는 명령을 전달합니다.  
2. **로컬 이미지 검색:** 데몬은 로컬 시스템에 hello-world:latest라는 이미지가 있는지 확인합니다.  
3. **이미지 다운로드 (Pull):** 로컬에 이미지가 없으므로, 데몬은 기본 레지스트리인 도커 허브에 접속하여 해당 이미지를 다운로드합니다.  
4. **컨테이너 생성:** 다운로드한 이미지를 기반으로 새로운 컨테이너를 생성합니다.  
5. **컨테이너 실행:** 컨테이너 내부의 실행 파일이 동작하여 "Hello from Docker\!" 메시지를 생성합니다.  
6. **출력 스트리밍:** 데몬은 컨테이너의 출력 결과를 클라이언트로 전송하고, 클라이언트는 이를 터미널에 표시합니다.  
7. **컨테이너 종료:** 실행 파일의 작업이 완료되면 컨테이너는 즉시 종료됩니다.

#### **최종 확인**

* **이미지 확인:** docker images 명령어를 실행하면 방금 다운로드한 hello-world 이미지가 목록에 나타나는 것을 볼 수 있습니다.36  
* **컨테이너 확인:** docker ps는 실행 중인 컨테이너만 보여주므로 아무것도 나타나지 않습니다. docker ps \-a 명령어를 사용하면, 방금 실행되었다가 'Exited' 상태로 종료된 hello-world 컨테이너의 기록을 확인할 수 있습니다.36

이 과정은 도커가 리눅스 커널에 깊이 의존하고 있음을 보여줍니다. Windows와 macOS에서의 설치는 단순히 도커를 실행하는 것이 아니라, WSL 2나 경량 가상 머신을 통해 리눅스 환경을 구축하고 그 위에서 도커 엔진을 구동하는 정교한 에뮬레이션 과정입니다.24 이는 프로덕션 환경에서는 리눅스가 표준으로 사용되며, Windows/macOS에서의 개발은 이러한 환경을 모방하는 것임을 시사합니다.

## **파트 3: 도커 CLI 마스터하기: 실용적인 명령어 레퍼런스**

도커의 모든 기능은 명령줄 인터페이스(CLI)를 통해 제어됩니다. 이 파트에서는 도커를 효과적으로 사용하기 위해 반드시 알아야 할 핵심 명령어들을 이미지 관리, 컨테이너 생명주기 관리, 실행 중인 컨테이너와의 상호작용이라는 세 가지 범주로 나누어 상세히 설명합니다.

### **섹션 3.1: 이미지 관리**

도커 이미지는 컨테이너의 기반이 되는 불변의 템플릿입니다. 이미지를 효율적으로 관리하는 것은 도커 워크플로의 핵심입니다.

* **docker login:** 도커 허브나 프라이빗 레지스트리에 인증합니다.  
  * **대화형 로그인:** docker login을 입력하면 사용자 이름과 비밀번호를 묻는 프롬프트가 나타납니다.40  
  * **비대화형/스크립트 로그인:** 보안을 위해 비밀번호를 직접 노출하지 않고 표준 입력(stdin)으로 전달하는 것이 좋습니다.  
    Bash  
    echo "$DOCKER\_PASSWORD" | docker login \-u myusername \--password-stdin

    40  
  * **프라이빗 레지스트리 로그인:** docker login my.registry.com과 같이 서버 주소를 명시합니다.40  
* **docker pull:** 레지스트리에서 이미지를 다운로드합니다.  
  * **문법:** docker pull \[이미지명\]:\[태그\].44  
  * **예시:** ubuntu 이미지의 22.04 버전을 다운로드합니다. 태그를 생략하면 기본값인 latest가 사용됩니다.44  
    Bash  
    docker pull ubuntu:22.04

* **docker images (또는 docker image ls):** 로컬에 저장된 이미지를 나열합니다.  
  * **기본 사용법:** REPOSITORY, TAG, IMAGE ID, CREATED, SIZE 등의 정보를 보여줍니다.37  
  * **옵션:**  
    * \-a: 중간 레이어를 포함한 모든 이미지를 표시합니다.46  
    * \-f "dangling=true": 이름 없는(dangling) 이미지만 필터링합니다.46  
    * \--format "{{.Repository}}:{{.Tag}}": 출력을 지정된 형식으로 커스터마이징합니다.46  
* **docker tag:** 기존 이미지에 새로운 태그(별칭)를 부여합니다.  
  * 태그는 특정 이미지 ID에 대한 참조일 뿐이며, 하나의 이미지는 여러 태그를 가질 수 있습니다.50  
  * **문법:** docker tag \[원본\_이미지\]:\[태그\]\[대상\_이미지\]:\[태그\].51  
  * **사용 예시:** 로컬의 my-app:1.0 이미지를 도커 허브에 푸시하기 위해 사용자 이름(myusername)을 붙여 태그를 지정합니다.  
    Bash  
    docker tag my-app:1.0 myusername/my-app:1.0

    41  
* **docker push:** 이미지를 레지스트리에 업로드합니다.  
  * **전제 조건:** 이미지는 반드시 \[레지스트리주소/\]\[사용자명/\]\[이미지명\]:\[태그\] 형식으로 태그되어 있어야 합니다.52  
  * **문법:** docker push \[저장소명\]:\[태그\].41  
    Bash  
    docker push myusername/my-app:1.0

* **docker rmi (또는 docker image rm):** 로컬 이미지를 삭제합니다.  
  * **기본 사용법:** docker rmi my-app:1.0.48  
  * **옵션:**  
    * \-f: 컨테이너가 사용 중인 이미지라도 강제로 삭제합니다 (컨테이너는 삭제되지 않음).49  
  * **모든 이미지 삭제:**  
    Bash  
    docker rmi $(docker images \-aq)

    48

### **섹션 3.2: 컨테이너 생명주기 관리**

컨테이너의 생성, 실행, 중지, 삭제를 관리하는 명령어들입니다.

* **docker run:** 이미지를 기반으로 컨테이너를 생성하고 시작하는 가장 핵심적인 명령어입니다.  
  * **기본 사용법:** docker run \[이미지명\].37  
  * **필수 플래그:**  
    * \-d 또는 \--detach: 컨테이너를 백그라운드에서 실행합니다.57  
    * \-p \[호스트\_포트\]:\[컨테이너\_포트\]: 호스트와 컨테이너 간의 포트를 매핑합니다.57  
    * \-it: 대화형 모드로 컨테이너의 셸에 접속할 때 사용합니다 (-i는 상호작용, \-t는 가상 터미널 할당).37  
    * \--name \[컨테이너명\]: 컨테이너에 식별하기 쉬운 이름을 부여합니다.57  
    * \--rm: 컨테이너가 종료될 때 자동으로 삭제합니다.58  
    * \-v \[볼륨명 또는 호스트\_경로\]:\[컨테이너\_경로\]: 볼륨을 마운트합니다 (파트 5에서 상세 설명).  
    * \-e \[키\]=\[값\]: 환경 변수를 설정합니다.57  
  * **명령어 재정의:** docker run \[이미지명\]\[실행할\_명령어\] 형식으로 이미지의 기본 명령어를 재정의할 수 있습니다.37  
* **docker ps (또는 docker container ls):** 컨테이너 목록을 조회합니다.  
  * **기본 사용법:** 실행 중인 컨테이너만 표시합니다.65  
  * **옵션:**  
    * \-a 또는 \--all: 중지된 컨테이너를 포함한 모든 컨테이너를 표시합니다.68  
    * \-q 또는 \--quiet: 컨테이너 ID만 출력하여 스크립팅에 유용합니다.68  
* **docker stop & docker start:**  
  * docker stop: 실행 중인 컨테이너를 정상적으로 중지시킵니다. SIGTERM 신호를 보내고, 일정 시간(기본 10초) 후에도 종료되지 않으면 SIGKILL 신호를 보냅니다.70  
  * docker start: 중지된 컨테이너를 다시 시작합니다. 컨테이너의 상태는 그대로 유지됩니다.73  
* **docker rm (또는 docker container rm):** 중지된 컨테이너를 삭제합니다.  
  * **문법:** docker rm.48  
  * 실행 중인 컨테이너는 삭제할 수 없으며, \-f 옵션을 사용하면 강제로 중지 후 삭제합니다.64  
  * **모든 컨테이너 중지 및 삭제:**  
    Bash  
    docker stop $(docker ps \-aq)  
    docker rm $(docker ps \-aq)

    55

### **섹션 3.3: 실행 중인 컨테이너와 상호작용하기**

실행 중인 컨테이너의 상태를 확인하거나 내부에서 명령을 실행하는 것은 디버깅과 운영에 필수적입니다.

* **docker exec:** 실행 중인 컨테이너 내부에서 명령어를 실행합니다.  
  * **대화형 셸 접속:** 디버깅을 위해 컨테이너 내부 셸에 접속합니다. Alpine 기반 이미지에서는 sh를 사용합니다.  
    Bash  
    docker exec \-it \[컨테이너명\] /bin/bash

    61  
  * **일회성 명령어 실행:**  
    Bash  
    docker exec \[컨테이너명\] ls \-l /app

    61  
* **docker logs:** 컨테이너의 로그를 확인합니다.  
  * 컨테이너의 주 프로세스가 출력하는 표준 출력(STDOUT)과 표준 에러(STDERR)를 보여줍니다.78  
  * **기본 사용법:** docker logs \[컨테이너명\].79  
  * **옵션:**  
    * \-f 또는 \--follow: 실시간으로 로그를 스트리밍합니다.79  
    * \--tail \[줄\_수\]: 마지막 N개의 로그 라인만 표시합니다.79  
    * \--since '2023-10-27T10:00:00': 특정 시간 이후의 로그만 표시합니다.79  
    * \-t 또는 \--timestamps: 로그 각 줄에 타임스탬프를 추가합니다.79  
* **docker inspect:** 도커 객체(컨테이너, 이미지 등)의 상세 정보를 JSON 형식으로 반환합니다.  
  * 컨테이너의 IP 주소, 마운트된 볼륨, 네트워크 설정 등 저수준의 정보를 확인할 때 유용합니다.67

도커 CLI는 단순히 개별 명령어를 실행하는 도구를 넘어, 명령어들을 조합하여 강력한 자동화 스크립트를 작성할 수 있도록 설계되었습니다. 예를 들어, docker ps \-q는 다른 명령어의 입력으로 사용되도록 컨테이너 ID만 출력합니다. 이처럼 명령어들을 파이프라인으로 연결하는 방식을 이해하면, 상위 오케스트레이션 도구 없이도 셸 스크립트만으로 컨테이너를 규모에 맞게 관리할 수 있습니다.

| 명령어 | 설명 | 주요 옵션 | 사용 예시 |
| :---- | :---- | :---- | :---- |
| **docker login** | 도커 레지스트리에 로그인 | \-u, \--password-stdin | echo $PWD | docker login \-u user \--password-stdin |
| **docker pull** | 레지스트리에서 이미지 다운로드 | \-a (모든 태그) | docker pull nginx:1.21-alpine |
| **docker images** | 로컬 이미지 목록 조회 | \-a, \-q, \-f, \--format | docker images \-f "dangling=true" |
| **docker tag** | 기존 이미지에 새 태그 부여 | 없음 | docker tag my-app:1.0 user/my-app:1.0 |
| **docker push** | 이미지를 레지스트리에 업로드 | \-a (모든 태그) | docker push user/my-app:1.0 |
| **docker rmi** | 로컬 이미지 삭제 | \-f (강제 삭제) | docker rmi my-app:1.0 |
| **docker build** | Dockerfile로 이미지 빌드 | \-t (태그 지정) | docker build \-t my-app:1.0. |
| **docker run** | 이미지로 컨테이너 생성 및 실행 | \-d, \-p, \-it, \--name, \--rm | docker run \-d \-p 80:80 \--name web nginx |
| **docker ps** | 컨테이너 목록 조회 | \-a (모두), \-q (ID만) | docker ps \-a |
| **docker stop** | 실행 중인 컨테이너 중지 | \-t (타임아웃) | docker stop web |
| **docker rm** | 중지된 컨테이너 삭제 | \-f (강제 삭제) | docker rm web |
| **docker exec** | 실행 중인 컨테이너에 명령어 실행 | \-it (대화형) | docker exec \-it web /bin/bash |
| **docker logs** | 컨테이너 로그 조회 | \-f (실시간), \--tail | docker logs \-f web |

## **파트 4: Dockerfile의 기술: 이미지 생성 자동화**

지금까지는 다른 사람이 만든 이미지를 사용했지만, 도커의 진정한 힘은 자신만의 맞춤형 이미지를 만드는 데 있습니다. Dockerfile은 이 과정을 자동화하고 코드로 관리하는 핵심 도구입니다. 이 파트에서는 효율적이고 유지보수 가능한 Dockerfile을 작성하는 방법을 심도 있게 다룹니다.

### **섹션 4.1: Dockerfile의 구조: 이미지 설계도 제작**

Dockerfile은 도커 이미지를 빌드하기 위한 명령어 스크립트를 담은 텍스트 파일입니다.82 이 파일을 통해 이미지 생성 과정을 자동화하여 언제 어디서나 동일한 이미지를 재현할 수 있습니다.8

#### **빌드 컨텍스트와 .dockerignore**

docker build 명령어를 실행할 때 마지막에 지정하는 경로(보통 .)를 '빌드 컨텍스트(build context)'라고 합니다. 도커 데몬은 이 경로에 있는 모든 파일과 디렉터리를 전송받아 이미지 빌드에 사용합니다.85 빌드에 불필요하거나 민감한 정보(예:

.git 폴더, node\_modules, 로컬 설정 파일)가 포함되면 빌드 속도가 느려지고 이미지 용량이 커지며 보안 위험이 발생할 수 있습니다.

이 문제를 해결하기 위해 빌드 컨텍스트의 루트 디렉터리에 .dockerignore 파일을 생성합니다. 이 파일에 제외할 파일이나 디렉터리 패턴을 명시하면, 해당 파일들은 도커 데몬으로 전송되지 않아 더 작고 안전하며 빠른 빌드가 가능해집니다.87

#### **레이어 기반 아키텍처와 캐싱**

도커 이미지는 여러 개의 레이어(layer)가 겹쳐진 구조를 가집니다. Dockerfile의 각 명령어(RUN, COPY, ADD 등)는 새로운 레이어를 생성합니다.47 도커는 빌드 시 각 레이어를 캐싱합니다. 이후 다시 빌드할 때, 변경되지 않은 명령어에 대해서는 기존에 캐시된 레이어를 재사용하여 빌드 시간을 획기적으로 단축합니다.47

### **섹션 4.2: Dockerfile 명령어 심층 분석**

효과적인 Dockerfile 작성을 위해 주요 명령어들의 역할과 사용법을 정확히 이해해야 합니다.

* **FROM:** Dockerfile의 첫 번째 명령어로, 빌드의 기반이 될 '베이스 이미지'를 지정합니다. 모든 빌드 과정은 이 베이스 이미지 위에서 시작됩니다.82  
  * 예시: FROM node:18-alpine  
* **WORKDIR:** 이후의 RUN, CMD, COPY 등의 명령어가 실행될 작업 디렉터리를 설정합니다. 지정된 디렉터리가 없으면 자동으로 생성됩니다.4  
  * 예시: WORKDIR /app  
* **COPY 와 ADD:**  
  * COPY: 빌드 컨텍스트의 파일이나 디렉터리를 이미지 내부로 복사합니다. 파일 복사 시 가장 명확하고 권장되는 방법입니다.82  
    * 예시: COPY..  
  * ADD: COPY와 유사하지만, 원격 URL에서 파일을 가져오거나 로컬의 tar 압축 파일을 자동으로 해제하는 추가 기능이 있습니다. 기능이 복잡하여 예측 불가능한 결과를 낳을 수 있으므로, 명확한 파일 복사가 필요할 때는 COPY를 사용하는 것이 좋습니다.91  
* **RUN:** 이미지 빌드 과정에서 셸 명령어를 실행합니다. 주로 패키지 설치, 소스 코드 컴파일 등에 사용됩니다.82  
  * 예시: RUN apt-get update && apt-get install \-y nginx  
* **CMD 와 ENTRYPOINT:** 컨테이너가 시작될 때 실행될 명령어를 지정한다는 공통점이 있지만, 중요한 차이가 있습니다.  
  * CMD: 컨테이너의 기본 실행 명령어를 정의합니다. docker run 명령어에 다른 명령어를 전달하면 쉽게 덮어쓸 수 있습니다. Dockerfile 내에 여러 CMD가 있으면 마지막 하나만 적용됩니다.82  
    * 예시: CMD \["node", "app.js"\]  
  * ENTRYPOINT: 컨테이너를 하나의 실행 파일처럼 작동하도록 설정합니다. docker run으로 전달된 인자들은 ENTRYPOINT 명령어의 인수로 추가됩니다. 덮어쓰기가 더 어렵습니다.94  
    * 예시: ENTRYPOINT \["/usr/sbin/nginx"\]  
  * **조합 사용:** ENTRYPOINT로 주 실행 파일을 고정하고, CMD로 기본 인자를 전달하는 방식이 일반적입니다.  
* **EXPOSE:** 컨테이너가 런타임에 수신 대기할 네트워크 포트를 명시합니다. 이는 문서화의 목적이 크며, 실제로 외부에서 포트에 접근하려면 docker run 시 \-p 옵션을 사용해야 합니다.21  
  * 예시: EXPOSE 80  
* **ENV:** 이미지 내에서 사용할 환경 변수를 설정합니다. 빌드 과정과 실행 중인 컨테이너 모두에서 참조할 수 있습니다.4  
  * 예시: ENV NODE\_ENV=production  
* **USER:** 이후의 RUN, CMD, ENTRYPOINT 명령어를 실행할 사용자 계정을 지정합니다. 보안을 위해 root가 아닌 별도의 사용자를 생성하여 지정하는 것이 가장 중요한 보안 수칙 중 하나입니다.4

### **섹션 4.3: 실전 워크숍: Node.js 웹 애플리케이션 Dockerizing**

지금까지 배운 내용을 바탕으로 간단한 Node.js 웹 애플리케이션을 Dockerizing하는 과정을 단계별로 진행합니다.88

1. **Node.js 애플리케이션 준비:** 간단한 "Hello World" Express.js 애플리케이션(src/index.js)과 의존성을 정의한 package.json 파일을 준비합니다.  
2. **.dockerignore 파일 작성:** 빌드 컨텍스트에서 불필요한 파일들을 제외합니다.

.git  
node\_modules  
npm-debug.log  
Dockerfile  
.dockerignore  
\`\`\`

87

3. **Dockerfile 작성:** 애플리케이션 이미지를 빌드하기 위한 Dockerfile을 작성합니다. 각 명령어의 순서는 도커의 레이어 캐싱을 최적화하도록 신중하게 배치해야 합니다.  
   Dockerfile  
   \# 1\. 가볍고 공식적인 베이스 이미지 사용  
   FROM node:18\-alpine

   \# 2\. 작업 디렉터리 설정  
   WORKDIR /usr/src/app

   \# 3\. 의존성 설치 (소스 코드 복사보다 먼저 수행하여 캐싱 활용 극대화)  
   COPY package\*.json./  
   RUN npm install \--production

   \# 4\. 애플리케이션 소스 코드 복사  
   COPY..

   \# 5\. 애플리케이션 포트 노출  
   EXPOSE 3000

   \# 6\. 애플리케이션 실행 명령어 정의  
   CMD \["node", "src/index.js"\]

4. **이미지 빌드:** 터미널에서 docker build 명령어를 사용하여 이미지를 빌드하고 my-node-app이라는 태그를 붙입니다.  
   Bash  
   docker build \-t my-node-app.

   23  
5. **컨테이너 실행:** 빌드된 이미지를 사용하여 컨테이너를 실행하고, 호스트의 4000번 포트를 컨테이너의 3000번 포트에 매핑합니다.  
   Bash  
   docker run \-p 4000:3000 \-d my-node-app

   23

   이제 웹 브라우저에서 http://localhost:4000에 접속하면 애플리케이션이 실행되는 것을 확인할 수 있습니다.

Dockerfile의 명령어 순서는 단순한 논리적 흐름을 넘어, 빌드 성능 최적화와 직결됩니다. 위 예시에서 소스 코드 전체를 복사하기 전에 package.json 파일을 먼저 복사하고 npm install을 실행한 것은 의도적인 최적화입니다. 소스 코드는 자주 변경되지만 package.json은 상대적으로 변경 빈도가 낮습니다. 이 순서로 작성하면, 소스 코드만 변경되었을 때 도커는 시간이 오래 걸리는 npm install 레이어를 캐시에서 재사용하고 변경된 소스 코드 복사 레이어만 새로 빌드합니다. 이처럼 애플리케이션의 변경 빈도를 고려하여 Dockerfile을 구조화하는 것이 효율적인 이미지 빌드의 핵심입니다.

## **파트 5: 고급 도커 아키텍처**

단일 컨테이너를 넘어, 실제 프로덕션 환경에서는 여러 컨테이너가 상호작용하고 데이터를 영속적으로 관리해야 합니다. 이 파트에서는 도커의 볼륨, 네트워크, 그리고 Docker Compose를 활용하여 복잡하고 상태를 가진(stateful) 애플리케이션을 구축하고 관리하는 고급 기법을 다룹니다.

### **섹션 5.1: 볼륨과 바인드 마운트를 이용한 데이터 영속성 관리**

컨테이너는 기본적으로 상태가 없는(stateless) 일시적인 존재로 설계되었습니다. 컨테이너가 삭제되면 내부의 쓰기 가능한 레이어에 저장된 모든 데이터도 함께 사라집니다.98 데이터베이스나 사용자 업로드 파일처럼 영속성이 필요한 데이터를 다루기 위해서는 외부 스토리지 연결이 필수적입니다.

#### **볼륨 (Volumes)**

볼륨은 도커가 관리하는 호스트 파일 시스템의 특정 경로에 데이터를 저장하는, 가장 권장되는 데이터 영속화 방식입니다.100

* **특징:** 컨테이너의 생명주기와 완전히 분리되어, 컨테이너가 삭제되어도 데이터는 안전하게 보존됩니다.98 여러 컨테이너가 하나의 볼륨을 동시에 공유할 수 있으며, 백업 및 마이그레이션이 용이합니다.98  
* **관리 명령어:** docker volume create, ls, inspect, rm, prune 등의 명령어로 볼륨을 직접 관리할 수 있습니다.99  
* **사용법:** docker run 시 \-v 또는 \--mount 플래그를 사용합니다. 이름 있는 볼륨을 사용하는 것이 일반적입니다.  
  Bash  
  \# 'my-db-data'라는 이름의 볼륨을 생성하고 컨테이너의 /var/lib/mysql 경로에 마운트  
  docker run \-d \--name mydb \-v my-db-data:/var/lib/mysql mysql

  98

#### **바인드 마운트 (Bind Mounts)**

바인드 마운트는 호스트 머신의 파일이나 디렉터리를 컨테이너 내부로 직접 마운트하는 방식입니다.98

* **특징:** 도커가 아닌 사용자가 호스트의 경로를 직접 제어합니다. 이 방식은 호스트의 파일 시스템 구조에 의존적이므로 이식성이 떨어질 수 있습니다.  
* **주요 사용 사례:** 개발 환경에서 주로 사용됩니다. 호스트에서 소스 코드를 수정하면 별도의 빌드 과정 없이 즉시 컨테이너 내부에 반영되어 실시간으로 변경 사항을 확인할 수 있습니다.88  
* **사용법:** \-v 플래그에 호스트의 절대 경로를 지정합니다.  
  Bash  
  \# 현재 디렉터리를 컨테이너의 /app 경로에 마운트  
  docker run \-d \-v $(pwd):/app my-dev-app

  99

#### **Tmpfs 마운트**

tmpfs 마운트는 데이터를 디스크가 아닌 호스트의 메모리에만 저장합니다. 컨테이너가 중지되면 데이터는 완전히 사라지며, 디스크 I/O가 발생하지 않아 임시 파일이나 캐시 데이터 처리에 사용하면 성능상 이점을 얻을 수 있습니다.100

| 기능 | 이름 있는 볼륨 (Named Volume) | 바인드 마운트 (Bind Mount) | Tmpfs 마운트 |
| :---- | :---- | :---- | :---- |
| **관리 주체** | 도커(Docker) | 사용자/호스트(User/Host) | 호스트 메모리(Host Memory) |
| **호스트 경로** | 도커가 관리하는 특정 경로 | 사용자가 지정하는 모든 경로 | 없음 (메모리) |
| **이식성** | 높음 | 낮음 | 해당 없음 |
| **주요 사용 사례** | 프로덕션 데이터 영속화 (DB, 업로드) | 개발 환경 (소스 코드 공유) | 비영속적 임시 데이터, 캐시 |
| **성능** | 높음 (네이티브 파일 시스템) | 높음 (네이티브 파일 시스템) | 매우 높음 (메모리 I/O) |
| **데이터 영속성** | 컨테이너 삭제 후에도 유지 | 호스트에 파일 유지 | 컨테이너 중지 시 삭제 |

### **섹션 5.2: 도커 네트워킹의 이해: 브리지부터 오버레이까지**

컨테이너는 격리된 환경이지만, 실제 애플리케이션은 여러 컨테이너 간의 통신 또는 외부와의 통신을 필요로 합니다. 도커 네트워킹은 이러한 통신을 안전하고 제어된 방식으로 가능하게 합니다.102

#### **핵심 개념**

도커는 리눅스 커널의 네트워크 네임스페이스(namespace) 기능을 사용하여 각 컨테이너에 격리된 네트워크 스택(IP 주소, 라우팅 테이블 등)을 제공합니다.104 그리고 가상 네트워크 인터페이스를 통해 컨테이너들이 서로 또는 외부와 통신할 수 있는 경로를 만듭니다.

#### **네트워크 드라이버**

* **bridge (기본값):** 단일 호스트 내에서 컨테이너들을 위한 기본 네트워크 드라이버입니다. 도커는 docker0이라는 가상 브리지를 생성하고, 이 네트워크에 연결된 컨테이너들은 사설 IP를 할당받습니다. 같은 브리지 네트워크에 속한 컨테이너들은 서로의 **컨테이너 이름**을 사용하여 통신할 수 있는데, 이는 도커가 내장 DNS 서버를 통해 이름 해석(name resolution)을 자동으로 제공하기 때문입니다.102  
* **host:** 컨테이너가 호스트의 네트워크 스택을 그대로 공유합니다. 네트워크 격리가 사라지는 대신, 포트 매핑 없이 호스트의 IP와 포트를 직접 사용하므로 성능이 가장 높습니다. 하지만 보안상 위험이 따릅니다.102  
* **overlay:** 여러 도커 호스트에 분산된 컨테이너들을 하나의 가상 네트워크로 연결합니다. 도커 스웜(Swarm) 모드와 같은 클러스터 환경에서 필수적인 드라이버입니다.102  
* **macvlan / ipvlan:** 컨테이너에 MAC 주소를 할당하여 네트워크상에서 물리적 장치처럼 보이게 하는 고급 드라이버입니다.102  
* **none:** 컨테이너의 모든 네트워킹을 비활성화합니다.103

#### **네트워크 관리 명령어**

* 네트워크 생성: docker network create my-net 103  
* 네트워크 목록: docker network ls 103  
* 네트워크 상세 정보: docker network inspect my-net 103  
* 컨테이너 연결: docker run \--network my-net... 또는 docker network connect my-net my-container 103

### **섹션 5.3: Docker Compose로 다중 컨테이너 애플리케이션 오케스트레이션**

웹 서버, API 서버, 데이터베이스, 캐시 서버 등 여러 컴포넌트로 구성된 애플리케이션을 개별 docker run 명령어로 관리하는 것은 매우 복잡하고 비효율적입니다.108 Docker Compose는 이러한 다중 컨테이너 애플리케이션을 하나의 YAML 파일로 정의하고 단일 명령어로 관리할 수 있게 해주는 강력한 도구입니다.109

#### **compose.yaml 파일 구조**

compose.yaml(또는 docker-compose.yml) 파일은 애플리케이션의 전체 구성을 정의합니다.113

* **services:** 애플리케이션을 구성하는 각 컨테이너를 '서비스'로 정의하는 핵심 섹션입니다.  
* **networks:** 서비스들이 사용할 커스텀 네트워크를 정의합니다.  
* **volumes:** 서비스들이 사용할 이름 있는 볼륨을 정의합니다.

#### **서비스 정의 예시**

YAML

services:  
  webapp:  
    build:.  
    ports:  
      \- "8000:5000"  
    volumes:  
      \-.:/code  
    environment:  
      \- REDIS\_HOST=redis  
    depends\_on:  
      \- redis

  redis:  
    image: "redis:alpine"

111

* build:.: 현재 디렉터리의 Dockerfile을 사용하여 webapp 서비스의 이미지를 빌드합니다.  
* image: "redis:alpine": 도커 허브의 redis:alpine 이미지를 redis 서비스에 사용합니다.  
* ports: 호스트의 8000번 포트를 webapp 컨테이너의 5000번 포트로 매핑합니다.  
* environment: webapp 컨테이너에 REDIS\_HOST 환경 변수를 redis로 설정합니다.  
* depends\_on: webapp 서비스가 redis 서비스보다 나중에 시작되도록 순서를 제어합니다.

#### **핵심 Compose 명령어**

* **docker compose up:** compose.yaml 파일에 정의된 모든 서비스를 빌드(필요시), 생성, 시작합니다. \-d 옵션을 붙이면 백그라운드에서 실행됩니다. 이 명령어는 자동으로 프로젝트를 위한 기본 브리지 네트워크를 생성하여 모든 서비스가 이 네트워크에 연결되도록 합니다.109  
* **docker compose down:** up으로 생성된 컨테이너, 네트워크를 중지하고 삭제합니다. \-v 옵션을 추가하면 볼륨까지 함께 삭제합니다.118  
* **기타 명령어:** ps, logs, exec, start, stop 등 개별 컨테이너 명령어와 유사하게 사용할 수 있습니다.111

Docker Compose는 단순한 다중 컨테이너 실행 도구를 넘어, 마이크로서비스 아키텍처의 핵심 개념인 '서비스 디스커버리(service discovery)'를 간단하게 구현합니다. Compose가 생성한 네트워크 내에서는 서비스 이름(예: redis)이 곧 해당 컨테이너의 호스트 이름으로 작동합니다. 이는 Compose의 내장 DNS 덕분이며, 개발자가 복잡한 네트워크 설정 없이도 서비스 간 통신을 쉽게 구현할 수 있도록 돕습니다. 이처럼 Docker Compose는 개발자가 쿠버네티스와 같은 복잡한 오케스트레이션 시스템으로 나아가기 전에 서비스 지향 아키텍처의 기본 원리를 학습하고 경험할 수 있는 훌륭한 디딤돌 역할을 합니다.

## **파트 6: 프로덕션급 도커: 최적화 및 보안**

개발 환경을 넘어 프로덕션 환경에서 도커를 안정적으로 운영하기 위해서는 이미지의 크기를 줄이고, 빌드 속도를 높이며, 보안을 강화하는 최적화 작업이 필수적입니다. 이 파트에서는 작고, 빠르며, 안전한 이미지를 만들고 컨테이너를 견고하게 실행하기 위한 핵심 전략과 모범 사례를 다룹니다.

### **섹션 6.1: 이미지 최적화 전략**

최적화된 이미지는 배포 시간을 단축하고, 저장 공간을 절약하며, 보안 취약점을 줄이는 효과를 가져옵니다.

#### **.dockerignore 활용**

빌드 컨텍스트의 크기를 최소화하는 것은 최적화의 첫걸음입니다. .dockerignore 파일을 사용하여 빌드에 불필요한 파일이나 민감한 정보(예: .git, node\_modules, 테스트 결과, 비밀번호 파일)를 빌드 컨텍스트에서 제외해야 합니다. 이는 빌드 속도를 높이고, 이미지 용량을 줄이며, 보안을 강화하는 가장 기본적인 방법입니다.86

#### **최소한의 베이스 이미지 선택**

ubuntu와 같은 완전한 OS 이미지 대신, 애플리케이션 실행에 필요한 최소한의 라이브러리만 포함된 경량 베이스 이미지를 사용하는 것이 매우 중요합니다.

* **alpine:** 매우 작고 보안에 중점을 둔 Linux 배포판으로, 이미지 크기를 크게 줄일 수 있습니다.96  
* **distroless:** 구글에서 만든 이미지로, 셸이나 패키지 관리자조차 없이 오직 애플리케이션과 그 런타임 종속성만 포함합니다. 공격 표면(attack surface)을 극단적으로 줄여 보안에 매우 유리합니다.127

#### **멀티-스테이지 빌드 (Multi-Stage Builds)**

이미지 크기를 획기적으로 줄이는 가장 강력한 기법입니다. 하나의 Dockerfile 내에서 여러 개의 FROM 구문을 사용하여 빌드 단계를 분리합니다.129

* **개념:** 첫 번째 스테이지(예: 'builder')에서는 컴파일러, 빌드 도구, 개발용 라이브러리 등 모든 도구를 포함한 SDK 이미지를 사용하여 애플리케이션을 컴파일하거나 빌드합니다. 이후 두 번째(최종) 스테이지에서는 alpine이나 distroless 같은 최소한의 런타임 이미지를 기반으로 시작하여, COPY \--from=builder 구문을 사용해 첫 번째 스테이지에서 생성된 실행 파일이나 아티팩트만 복사해옵니다.127  
* **효과:** 최종 이미지에는 소스 코드, 컴파일러, 빌드 도구 등 프로덕션 실행에 불필요한 모든 것들이 완전히 제거됩니다. 이는 이미지 크기를 수백 MB에서 수십 MB로 줄여 배포 속도를 높이고 보안을 크게 강화합니다.128

**Go 애플리케이션 멀티-스테이지 빌드 예시:**

Dockerfile

\# \--- 빌드 스테이지 \---  
FROM golang:1.21 AS builder  
WORKDIR /app  
COPY..  
RUN CGO\_ENABLED=0 GOOS=linux go build \-o myapp.

\# \--- 최종 스테이지 \---  
FROM alpine:latest  
WORKDIR /root/  
COPY \--from=builder /app/myapp.  
CMD \["./myapp"\]

130

#### **RUN 명령어 최적화**

여러 RUN 명령어를 &&를 사용하여 하나로 연결하면 이미지 레이어 수를 줄일 수 있습니다. 또한, 패키지 설치 후에는 불필요한 캐시 파일을 삭제하여 레이어 크기를 최소화해야 합니다.

Dockerfile

RUN apt-get update && \\  
    apt-get install \-y \--no-install-recommends nginx && \\  
    rm \-rf /var/lib/apt/lists/\*

134

### **섹션 6.2: 필수 도커 보안 모범 사례**

도커 보안은 호스트, 이미지, 컨테이너 런타임에 걸친 다층적인 접근이 필요합니다. 최적화된 이미지가 곧 더 안전한 이미지라는 점을 기억해야 합니다.

#### **호스트 및 데몬 보안**

* **지속적인 업데이트:** 호스트 OS와 도커 엔진을 항상 최신 상태로 유지하여 알려진 취약점을 패치해야 합니다.92  
* **도커 데몬 소켓 보호:** /var/run/docker.sock 파일에 대한 접근 권한은 호스트의 root 권한과 동일합니다. 이 소켓을 절대로 인터넷에 노출하거나 신뢰할 수 없는 컨테이너에 마운트해서는 안 됩니다.92

#### **이미지 보안**

* **신뢰할 수 있는 이미지 사용:** 도커 공식 이미지(Docker Official Images)나 검증된 게시자(Verified Publisher)가 제공하는 이미지를 베이스 이미지로 사용해야 합니다.126  
* **이미지 취약점 스캔:** Docker Scout, Trivy, Snyk과 같은 도구를 CI/CD 파이프라인에 통합하여, 빌드된 이미지 내의 운영체제 패키지 및 애플리케이션 라이브러리에 존재하는 알려진 보안 취약점을 지속적으로 스캔하고 관리해야 합니다.92  
* **도커 콘텐츠 신뢰(Docker Content Trust):** 이미지 서명 기능을 활성화하여, 레지스트리에서 이미지를 가져올 때 해당 이미지가 변조되지 않았음을 보장할 수 있습니다.126

#### **컨테이너 런타임 보안**

* **루트가 아닌 사용자로 실행 (가장 중요):** Dockerfile에서 USER 명령어를 사용하여 전용 사용자를 생성하고, 컨테이너가 해당 사용자로 실행되도록 설정해야 합니다. 이는 컨테이너 탈출(container escape) 공격이 발생하더라도 호스트에 미치는 피해를 최소화하는 가장 효과적인 방법입니다.92  
* **읽기 전용 파일 시스템 사용:** docker run \--read-only 옵션을 사용하여 컨테이너의 루트 파일 시스템을 읽기 전용으로 실행하고, 데이터 쓰기가 필요한 특정 경로에만 볼륨을 마운트합니다. 이는 공격자가 컨테이너 내부에 악성 코드를 설치하거나 기존 파일을 변경하는 것을 방지합니다.92  
* **권한 제한 (Least Privilege):** 컨테이너에 불필요한 리눅스 커널 케이퍼빌리티(capability)를 모두 제거(--cap-drop=ALL)하고, 애플리케이션 실행에 반드시 필요한 최소한의 권한만 추가(--cap-add=...)해야 합니다.92  
* **권한 상승 방지:** \--security-opt=no-new-privileges 플래그를 사용하여 컨테이너 내부의 프로세스가 setuid나 setgid 바이너리를 통해 추가적인 권한을 획득하는 것을 막아야 합니다.92  
* **리소스 제한:** \--cpus와 \--memory 옵션을 사용하여 각 컨테이너가 사용할 수 있는 CPU와 메모리 양을 제한해야 합니다. 이는 특정 컨테이너의 과도한 리소스 사용으로 인한 서비스 거부(DoS) 공격을 방지하고, 전체 시스템의 안정성을 보장합니다.92

결론적으로, 도커의 보안과 최적화는 분리된 개념이 아닙니다. 멀티-스테이지 빌드와 경량 베이스 이미지 사용과 같은 최적화 기법은 이미지 크기를 줄일 뿐만 아니라, 불필요한 구성 요소를 제거하여 공격 표면을 직접적으로 축소시키는 핵심적인 보안 활동입니다. 따라서 안전한 도커 워크플로는 필연적으로 최적화된 워크플로이며, 이러한 통합적인 접근 방식이야말로 프로덕션 환경에서 도커를 성공적으로 운영하는 비결입니다.

### **결론**

도커는 현대 소프트웨어 개발 및 배포의 패러다임을 바꾼 혁신적인 기술입니다. 이 가이드는 도커의 근본적인 개념인 '환경 불일치' 문제 해결부터 시작하여, 가상 머신과의 아키텍처 비교, 핵심 생태계 구성 요소의 이해에 이르기까지 도커의 기본 철학을 다루었습니다.

실용적인 측면에서는 Windows, macOS, Linux 환경에서의 설치 과정과 필수적인 CLI 명령어들을 상세히 살펴보았으며, 이를 통해 사용자는 이미지를 관리하고 컨테이너의 생명주기를 제어하며 실행 중인 애플리케이션과 상호작용하는 능력을 갖추게 됩니다. 나아가, Dockerfile 작성법, 데이터 영속성을 위한 볼륨 관리, 컨테이너 간 통신을 위한 네트워킹, 그리고 다중 컨테이너 애플리케이션을 효율적으로 관리하는 Docker Compose까지, 단일 컨테이너를 넘어 복잡한 애플리케이션을 구축하고 운영하는 고급 기법들을 탐구했습니다.

마지막으로, 프로덕션 환경의 핵심 요구사항인 최적화와 보안을 강조했습니다. 멀티-스테이지 빌드와 같은 이미지 최적화 기법이 어떻게 더 작고 빠른 이미지를 만들 뿐만 아니라, 공격 표면을 줄여 보안을 강화하는지와 같은 상호 연관성을 분석했습니다. 루트가 아닌 사용자로 컨테이너를 실행하고, 최소한의 권한을 부여하며, 리소스를 제한하는 등의 런타임 보안 수칙은 안정적이고 신뢰할 수 있는 서비스를 운영하기 위한 필수 요소입니다.

결론적으로, 도커를 마스터한다는 것은 단순히 명령어 몇 개를 아는 것을 넘어, Dockerfile부터 런타임 환경에 이르기까지 전체 생명주기에 걸쳐 최적화와 보안을 고려하는 총체적인 접근 방식을 내재화하는 것을 의미합니다. 이 가이드가 제공하는 지식과 모범 사례를 바탕으로, 개발자와 운영자는 더 빠르고, 안정적이며, 안전하게 애플리케이션을 구축하고 배포하는 역량을 갖추게 될 것입니다.

#### **참고 자료**

1. Docker란 무엇입니까? \- AWS, 8월 27, 2025에 액세스, [https://aws.amazon.com/ko/docker/](https://aws.amazon.com/ko/docker/)  
2. \[ Docker \#01 알아보기 1/5 \] \- 도커란 무엇인가? \- DataArtist, 8월 27, 2025에 액세스, [https://artistdata.tistory.com/3](https://artistdata.tistory.com/3)  
3. www.oracle.com, 8월 27, 2025에 액세스, [https://www.oracle.com/kr/cloud/cloud-native/container-registry/what-is-docker/\#:\~:text=Docker%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%8A%94%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98,%EC%95%88%EC%A0%95%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EC%8B%A4%ED%96%89%EB%90%A0%20%EC%88%98%20%EC%9E%88%EC%A3%A0.](https://www.oracle.com/kr/cloud/cloud-native/container-registry/what-is-docker/#:~:text=Docker%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%8A%94%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98,%EC%95%88%EC%A0%95%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EC%8B%A4%ED%96%89%EB%90%A0%20%EC%88%98%20%EC%9E%88%EC%A3%A0.)  
4. \[Docker\] 도커란 무엇인가?, 8월 27, 2025에 액세스, [https://squirmm.tistory.com/entry/Docker-%EB%8F%84%EC%BB%A4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80](https://squirmm.tistory.com/entry/Docker-%EB%8F%84%EC%BB%A4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)  
5. \[Docker\] 도커란 무엇인가, 8월 27, 2025에 액세스, [https://woo-chang.tistory.com/48](https://woo-chang.tistory.com/48)  
6. \[Docker\] 기초내용 (1) \- 이미지, 컨테이너, 구성 \- 아무거나 잘먹어요 \- 티스토리, 8월 27, 2025에 액세스, [https://sdhg12.tistory.com/12](https://sdhg12.tistory.com/12)  
7. Docker란? \- .NET | Microsoft Learn, 8월 27, 2025에 액세스, [https://learn.microsoft.com/ko-kr/dotnet/architecture/microservices/container-docker-introduction/docker-defined](https://learn.microsoft.com/ko-kr/dotnet/architecture/microservices/container-docker-introduction/docker-defined)  
8. \[Container\] 도커 알아보기(1) \- 이미지와 컨테이너 \- 길은 가면, 뒤에 있다., 8월 27, 2025에 액세스, [https://12bme.tistory.com/585](https://12bme.tistory.com/585)  
9. 도커란 무엇인가 \- gh-leokim-github-io, 8월 27, 2025에 액세스, [https://ghleokim.github.io/%EB%8F%84%EC%BB%A4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/](https://ghleokim.github.io/%EB%8F%84%EC%BB%A4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/)  
10. 도커 : Docker 와 VM의 차이 \- velog, 8월 27, 2025에 액세스, [https://velog.io/@kdaeyeop/%EB%8F%84%EC%BB%A4-Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4](https://velog.io/@kdaeyeop/%EB%8F%84%EC%BB%A4-Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4)  
11. Docker(Container)와 VM의 차이는 무엇인가? \- 내가 보기 위한 기록, 8월 27, 2025에 액세스, [https://sunrise-min.tistory.com/entry/Docker%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80](https://sunrise-min.tistory.com/entry/Docker%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)  
12. 도커(Docker)와 가상머신(Virtual Machine) 비교 \- 천방지축 개발노트 \- 티스토리, 8월 27, 2025에 액세스, [https://hoon93.tistory.com/41](https://hoon93.tistory.com/41)  
13. Docker 와 VM의 차이점 \- 내일을 위해, 8월 27, 2025에 액세스, [https://tistory.hu-nie.com/entry/Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90](https://tistory.hu-nie.com/entry/Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90)  
14. Docker \- 컨테이너란? (Container) \- 클라우드 엔지니어 Won의 성장 블로그, 8월 27, 2025에 액세스, [https://captcha.tistory.com/46](https://captcha.tistory.com/46)  
15. \[Docker\] 애플리케이션 배포의 혁신: Docker와 VM 비교하기 \- 데이터 AI 벌집, 8월 27, 2025에 액세스, [https://datasciencebeehive.tistory.com/14](https://datasciencebeehive.tistory.com/14)  
16. Docker 및 VM 비교 \- 애플리케이션 배포 기술 간의 차이 \- AWS, 8월 27, 2025에 액세스, [https://aws.amazon.com/ko/compare/the-difference-between-docker-vm/](https://aws.amazon.com/ko/compare/the-difference-between-docker-vm/)  
17. Docker란 무엇인가? | Oracle 대한민국, 8월 27, 2025에 액세스, [https://www.oracle.com/kr/cloud/cloud-native/container-registry/what-is-docker/](https://www.oracle.com/kr/cloud/cloud-native/container-registry/what-is-docker/)  
18. \[Docker\] 도커, 컨테이너 기술 제대로 이해하기 \- velog, 8월 27, 2025에 액세스, [https://velog.io/@enjoy89/Docker-%EB%8F%84%EC%BB%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B8%B0%EC%88%A0-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0](https://velog.io/@enjoy89/Docker-%EB%8F%84%EC%BB%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B8%B0%EC%88%A0-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)  
19. \[Docker\] Docker 이해하기 \-1 : 기초 이론(아키텍처, 흐름, 주요 용어) \- Contributor9, 8월 27, 2025에 액세스, [https://adjh54.tistory.com/352](https://adjh54.tistory.com/352)  
20. Docker 이미지와 컨테이너 비교 \- 애플리케이션 배포 기술 간의 차이점 \- AWS, 8월 27, 2025에 액세스, [https://aws.amazon.com/ko/compare/the-difference-between-docker-images-and-containers/](https://aws.amazon.com/ko/compare/the-difference-between-docker-images-and-containers/)  
21. 도커와 컨테이너의 이해 (3/3) \- Docker image, Dockerfile, Docker compose \- 안랩클라우드메이트 기술 블로그, 8월 27, 2025에 액세스, [https://tech.cloudmt.co.kr/2022/06/29/%EB%8F%84%EC%BB%A4%EC%99%80-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EC%9D%B4%ED%95%B4-3-3-docker-image-dockerfile-docker-compose/](https://tech.cloudmt.co.kr/2022/06/29/%EB%8F%84%EC%BB%A4%EC%99%80-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EC%9D%B4%ED%95%B4-3-3-docker-image-dockerfile-docker-compose/)  
22. Docker Container와 Image란 무엇인가? \- 내가 보기 위한 기록 \- 티스토리, 8월 27, 2025에 액세스, [https://sunrise-min.tistory.com/entry/Docker-Container%EC%99%80-Image%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80](https://sunrise-min.tistory.com/entry/Docker-Container%EC%99%80-Image%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)  
23. \[Docker\] 도커 컨테이너(Docker Container)와 도커 이미지(Docker Image)에 대해서 \- 컴도리돌이, 8월 27, 2025에 액세스, [https://comdolidol-i.tistory.com/412](https://comdolidol-i.tistory.com/412)  
24. Install Docker Desktop on Windows \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/desktop/setup/install/windows-install/](https://docs.docker.com/desktop/setup/install/windows-install/)  
25. How To Install Docker on Windows? \[Made Easy\] \- Simplilearn.com, 8월 27, 2025에 액세스, [https://www.simplilearn.com/tutorials/docker-tutorial/install-docker-on-windows](https://www.simplilearn.com/tutorials/docker-tutorial/install-docker-on-windows)  
26. Comprehensive Guide: Installing Docker and Docker Compose on Windows, Linux, and macOS | by Piyush Kashyap | Medium, 8월 27, 2025에 액세스, [https://medium.com/@piyushkashyap045/comprehensive-guide-installing-docker-and-docker-compose-on-windows-linux-and-macos-a022cf82ac0b](https://medium.com/@piyushkashyap045/comprehensive-guide-installing-docker-and-docker-compose-on-windows-linux-and-macos-a022cf82ac0b)  
27. Get Started | Docker, 8월 27, 2025에 액세스, [https://www.docker.com/get-started/](https://www.docker.com/get-started/)  
28. Get Docker Desktop \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/get-started/introduction/get-docker-desktop/](https://docs.docker.com/get-started/introduction/get-docker-desktop/)  
29. Install Docker Desktop on Mac \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/desktop/setup/install/mac-install/](https://docs.docker.com/desktop/setup/install/mac-install/)  
30. Best way to install Docker on a Mac, 8월 27, 2025에 액세스, [https://richstone.io/best-way-to-install-docker-on-a-mac/](https://richstone.io/best-way-to-install-docker-on-a-mac/)  
31. Docker for Mac: Homebrew Step-by-Step Tutorial \- Cprime, 8월 27, 2025에 액세스, [https://www.cprime.com/resources/blog/docker-for-mac-with-homebrew-a-step-by-step-tutorial/](https://www.cprime.com/resources/blog/docker-for-mac-with-homebrew-a-step-by-step-tutorial/)  
32. Install Docker Engine on Ubuntu, 8월 27, 2025에 액세스, [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/)  
33. Install Docker on Ubuntu: Quick & Easy Steps \- Simplilearn.com, 8월 27, 2025에 액세스, [https://www.simplilearn.com/tutorials/docker-tutorial/how-to-install-docker-on-ubuntu](https://www.simplilearn.com/tutorials/docker-tutorial/how-to-install-docker-on-ubuntu)  
34. Install Docker on Ubuntu: From Setup to First Container \- DataCamp, 8월 27, 2025에 액세스, [https://www.datacamp.com/tutorial/install-docker-on-ubuntu](https://www.datacamp.com/tutorial/install-docker-on-ubuntu)  
35. How to Install Docker on Ubuntu – Step-by-Step Guide | DigitalOcean, 8월 27, 2025에 액세스, [https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-22-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-22-04)  
36. Demonstrating Hello World Example \- Docker \- Collabnix, 8월 27, 2025에 액세스, [https://dockerlabs.collabnix.com/beginners/helloworld/](https://dockerlabs.collabnix.com/beginners/helloworld/)  
37. A Docker Tutorial for Beginners, 8월 27, 2025에 액세스, [https://docker-curriculum.com/](https://docker-curriculum.com/)  
38. hello-world \- Official Image \- Docker Hub, 8월 27, 2025에 액세스, [https://hub.docker.com/\_/hello-world](https://hub.docker.com/_/hello-world)  
39. Running Docker on macOS Without Docker Desktop: Alternatives, Limitations, and Best Practices \- DEV Community, 8월 27, 2025에 액세스, [https://dev.to/mochafreddo/running-docker-on-macos-without-docker-desktop-64o](https://dev.to/mochafreddo/running-docker-on-macos-without-docker-desktop-64o)  
40. Docker commands Guide \- docker login with examples \- DevOpsSchool.com, 8월 27, 2025에 액세스, [https://www.devopsschool.com/blog/docker-login/](https://www.devopsschool.com/blog/docker-login/)  
41. Publishing Images to Docker Hub \- GeeksforGeeks, 8월 27, 2025에 액세스, [https://www.geeksforgeeks.org/devops/docker-publishing-images-to-docker-hub/](https://www.geeksforgeeks.org/devops/docker-publishing-images-to-docker-hub/)  
42. docker login \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/reference/cli/docker/login/](https://docs.docker.com/reference/cli/docker/login/)  
43. Automatic Docker Login in a Bash Script | Baeldung on Linux, 8월 27, 2025에 액세스, [https://www.baeldung.com/linux/docker-bash-automatic-login](https://www.baeldung.com/linux/docker-bash-automatic-login)  
44. How to Use Docker Commands (Push and Pull) with Images \- Atlantic.Net, 8월 27, 2025에 액세스, [https://www.atlantic.net/dedicated-server-hosting/how-to-use-docker-push-and-docker-pull-command-to-upload-and-download-images-to-docker-hub/](https://www.atlantic.net/dedicated-server-hosting/how-to-use-docker-push-and-docker-pull-command-to-upload-and-download-images-to-docker-hub/)  
45. How to pull a Docker image \- LabEx, 8월 27, 2025에 액세스, [https://labex.io/tutorials/docker-how-to-pull-a-docker-image-411581](https://labex.io/tutorials/docker-how-to-pull-a-docker-image-411581)  
46. docker image ls \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/reference/cli/docker/image/ls/](https://docs.docker.com/reference/cli/docker/image/ls/)  
47. Docker \- Images \- Tutorials Point, 8월 27, 2025에 액세스, [https://www.tutorialspoint.com/docker/docker\_images.htm](https://www.tutorialspoint.com/docker/docker_images.htm)  
48. How to Remove Images and Containers in Docker \- freeCodeCamp, 8월 27, 2025에 액세스, [https://www.freecodecamp.org/news/how-to-remove-images-in-docker/](https://www.freecodecamp.org/news/how-to-remove-images-in-docker/)  
49. Docker commands Guide \- docker rmi with examples \- DevOpsSchool.com, 8월 27, 2025에 액세스, [https://www.devopsschool.com/blog/docker-rmi/](https://www.devopsschool.com/blog/docker-rmi/)  
50. A Guide to Tag in Docker | Baeldung on Ops, 8월 27, 2025에 액세스, [https://www.baeldung.com/ops/docker-tag](https://www.baeldung.com/ops/docker-tag)  
51. docker image tag \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/reference/cli/docker/image/tag/](https://docs.docker.com/reference/cli/docker/image/tag/)  
52. Push images \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/docker-hub/repos/manage/hub-images/push/](https://docs.docker.com/docker-hub/repos/manage/hub-images/push/)  
53. Using Docker Push to Publish Images to Docker Hub \- CloudBees, 8월 27, 2025에 액세스, [https://www.cloudbees.com/blog/using-docker-push-to-publish-images-to-dockerhub](https://www.cloudbees.com/blog/using-docker-push-to-publish-images-to-dockerhub)  
54. Build and push your first image \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/get-started/introduction/build-and-push-first-image/](https://docs.docker.com/get-started/introduction/build-and-push-first-image/)  
55. How To Remove Docker Images, Containers, and Volumes \- DigitalOcean, 8월 27, 2025에 액세스, [https://www.digitalocean.com/community/tutorials/how-to-remove-docker-images-containers-and-volumes](https://www.digitalocean.com/community/tutorials/how-to-remove-docker-images-containers-and-volumes)  
56. How to Clean Up: Deleting All Docker Images \- CloudBees, 8월 27, 2025에 액세스, [https://www.cloudbees.com/blog/how-to-clean-up-deleting-all-docker-images](https://www.cloudbees.com/blog/how-to-clean-up-deleting-all-docker-images)  
57. A Detailed Guide on Docker run Command \- Refine dev, 8월 27, 2025에 액세스, [https://refine.dev/blog/docker-run-command/](https://refine.dev/blog/docker-run-command/)  
58. docker run Command: Syntax, Options, Examples \- phoenixNAP, 8월 27, 2025에 액세스, [https://phoenixnap.com/kb/docker-run-command-with-examples](https://phoenixnap.com/kb/docker-run-command-with-examples)  
59. Docker Run Command \- Complete Tutorial For Beginners \- GeeksforGeeks, 8월 27, 2025에 액세스, [https://www.geeksforgeeks.org/devops/docker-run-command/](https://www.geeksforgeeks.org/devops/docker-run-command/)  
60. Docker and Port Forwarding \- Ethereum Blockchain Developer, 8월 27, 2025에 액세스, [https://www.ethereum-blockchain-developer.com/courses/learn-docker/understanding-port-mapping](https://www.ethereum-blockchain-developer.com/courses/learn-docker/understanding-port-mapping)  
61. Docker Exec Command \- How to Use It, Tips & Examples \- Spacelift, 8월 27, 2025에 액세스, [https://spacelift.io/blog/docker-exec](https://spacelift.io/blog/docker-exec)  
62. The Interactive and TTY Options in docker run | Baeldung on Linux, 8월 27, 2025에 액세스, [https://www.baeldung.com/linux/docker-run-interactive-tty-options](https://www.baeldung.com/linux/docker-run-interactive-tty-options)  
63. docker container run \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/reference/cli/docker/container/run/](https://docs.docker.com/reference/cli/docker/container/run/)  
64. single command to stop and remove docker container \- Stack Overflow, 8월 27, 2025에 액세스, [https://stackoverflow.com/questions/35122773/single-command-to-stop-and-remove-docker-container](https://stackoverflow.com/questions/35122773/single-command-to-stop-and-remove-docker-container)  
65. What is Docker PS Command ? \- GeeksforGeeks, 8월 27, 2025에 액세스, [https://www.geeksforgeeks.org/devops/docker-ps-command/](https://www.geeksforgeeks.org/devops/docker-ps-command/)  
66. Docker ps: Basic and Advanced Usage Guide \- IOFLOOD.com, 8월 27, 2025에 액세스, [https://ioflood.com/blog/docker-ps-basic-and-advanced-usage-guide/](https://ioflood.com/blog/docker-ps-basic-and-advanced-usage-guide/)  
67. Docker Ps Command \- When to Use & Examples \- Spacelift, 8월 27, 2025에 액세스, [https://spacelift.io/blog/docker-ps](https://spacelift.io/blog/docker-ps)  
68. How to customize Docker ps output \- LabEx, 8월 27, 2025에 액세스, [https://labex.io/tutorials/docker-how-to-customize-docker-ps-output-418058](https://labex.io/tutorials/docker-how-to-customize-docker-ps-output-418058)  
69. docker container ls \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/reference/cli/docker/container/ls/](https://docs.docker.com/reference/cli/docker/container/ls/)  
70. How to Stop and Remove Docker Containers \- Spacelift, 8월 27, 2025에 액세스, [https://spacelift.io/blog/docker-stop-container](https://spacelift.io/blog/docker-stop-container)  
71. Docker: How to Stop and Remove All Containers at Once \- CloudBees, 8월 27, 2025에 액세스, [https://www.cloudbees.com/blog/docker-how-to-stop-and-remove-all-containers-at-once](https://www.cloudbees.com/blog/docker-how-to-stop-and-remove-all-containers-at-once)  
72. docker container stop \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/reference/cli/docker/container/stop/](https://docs.docker.com/reference/cli/docker/container/stop/)  
73. Run containers \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/guides/golang/run-containers/](https://docs.docker.com/guides/golang/run-containers/)  
74. What Is Docker rm Command ? \- GeeksforGeeks, 8월 27, 2025에 액세스, [https://www.geeksforgeeks.org/devops/what-is-docker-rm-command/](https://www.geeksforgeeks.org/devops/what-is-docker-rm-command/)  
75. How to Use docker exec to Access and Manage Containers | DigitalOcean, 8월 27, 2025에 액세스, [https://www.digitalocean.com/community/tutorials/how-to-use-docker-exec-to-run-commands-in-a-docker-container](https://www.digitalocean.com/community/tutorials/how-to-use-docker-exec-to-run-commands-in-a-docker-container)  
76. How to Use Docker Exec to Accessing Running Containers | Better Stack Community, 8월 27, 2025에 액세스, [https://betterstack.com/community/guides/scaling-docker/docker-exec/](https://betterstack.com/community/guides/scaling-docker/docker-exec/)  
77. An Introductory How-To, With Examples, of Docker Exec \- CloudBees, 8월 27, 2025에 액세스, [https://www.cloudbees.com/blog/introductory-how-to-examples-docker-exec](https://www.cloudbees.com/blog/introductory-how-to-examples-docker-exec)  
78. Logs and metrics \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/engine/logging/](https://docs.docker.com/engine/logging/)  
79. Guide to Docker logs and how to see them \- New Relic, 8월 27, 2025에 액세스, [https://newrelic.com/blog/best-practices/docker-logs](https://newrelic.com/blog/best-practices/docker-logs)  
80. Docker Container Logs: How to View & Manage \- Spacelift, 8월 27, 2025에 액세스, [https://spacelift.io/blog/docker-container-logs](https://spacelift.io/blog/docker-container-logs)  
81. Best Practices for Docker Image Management and Versioning \- GeeksforGeeks, 8월 27, 2025에 액세스, [https://www.geeksforgeeks.org/devops/docker-versioning-best-practices/](https://www.geeksforgeeks.org/devops/docker-versioning-best-practices/)  
82. Writing a Dockerfile \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/get-started/docker-concepts/building-images/writing-a-dockerfile/](https://docs.docker.com/get-started/docker-concepts/building-images/writing-a-dockerfile/)  
83. Docker Tutorial \- GeeksforGeeks, 8월 27, 2025에 액세스, [https://www.geeksforgeeks.org/devops/docker-tutorial/](https://www.geeksforgeeks.org/devops/docker-tutorial/)  
84. The complete guide to getting started with building Docker images \- Depot, 8월 27, 2025에 액세스, [https://depot.dev/blog/docker-build-image](https://depot.dev/blog/docker-build-image)  
85. Docker Build: A Beginner's Guide to Building Docker Images \- Stackify, 8월 27, 2025에 액세스, [https://stackify.com/docker-build-a-beginners-guide-to-building-docker-images/](https://stackify.com/docker-build-a-beginners-guide-to-building-docker-images/)  
86. Leveraging the dockerignore File to Create Smaller Images \- CloudBees, 8월 27, 2025에 액세스, [https://www.cloudbees.com/blog/leveraging-the-dockerignore-file-to-create-smaller-images](https://www.cloudbees.com/blog/leveraging-the-dockerignore-file-to-create-smaller-images)  
87. Docker Building Files \- Tutorialspoint, 8월 27, 2025에 액세스, [https://www.tutorialspoint.com/docker/building\_docker\_files.htm](https://www.tutorialspoint.com/docker/building_docker_files.htm)  
88. An Exhaustive Guide to Writing Dockerfiles for Node.js Web Apps \- Hasura, 8월 27, 2025에 액세스, [https://hasura.io/blog/an-exhaustive-guide-to-writing-dockerfiles-for-node-js-web-apps-bbee6bd2f3c4](https://hasura.io/blog/an-exhaustive-guide-to-writing-dockerfiles-for-node-js-web-apps-bbee6bd2f3c4)  
89. Dockerfile overview \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/build/concepts/dockerfile/](https://docs.docker.com/build/concepts/dockerfile/)  
90. Part 8: Image-building best practices \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/get-started/workshop/09\_image\_best/](https://docs.docker.com/get-started/workshop/09_image_best/)  
91. What Is a Dockerfile And How To Build It \- Best Practices \- Spacelift, 8월 27, 2025에 액세스, [https://spacelift.io/blog/dockerfile](https://spacelift.io/blog/dockerfile)  
92. Docker Security \- OWASP Cheat Sheet Series, 8월 27, 2025에 액세스, [https://cheatsheetseries.owasp.org/cheatsheets/Docker\_Security\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html)  
93. Difference between RUN and CMD in a Dockerfile \- Stack Overflow, 8월 27, 2025에 액세스, [https://stackoverflow.com/questions/37461868/difference-between-run-and-cmd-in-a-dockerfile](https://stackoverflow.com/questions/37461868/difference-between-run-and-cmd-in-a-dockerfile)  
94. Docker CMD vs. ENTRYPOINT: What's the Difference and How to Choose \- BMC Software, 8월 27, 2025에 액세스, [https://www.bmc.com/blogs/docker-cmd-vs-entrypoint/](https://www.bmc.com/blogs/docker-cmd-vs-entrypoint/)  
95. Part 1: Containerize an application \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/get-started/workshop/02\_our\_app/](https://docs.docker.com/get-started/workshop/02_our_app/)  
96. How to Dockerize a Node.js application \- Buddy.Works, 8월 27, 2025에 액세스, [https://buddy.works/guides/how-dockerize-node-application](https://buddy.works/guides/how-dockerize-node-application)  
97. Dockerizing a Node.js and Express.js APP | by Muhammad Naqeeb | Medium, 8월 27, 2025에 액세스, [https://medium.com/@muhammadnaqeeb/dockerizing-a-node-js-and-express-js-app-9cb31cf9139e](https://medium.com/@muhammadnaqeeb/dockerizing-a-node-js-and-express-js-app-9cb31cf9139e)  
98. Understanding Docker Volumes: A Comprehensive Guide | by Rahul \- Medium, 8월 27, 2025에 액세스, [https://therahulsarkar.medium.com/understanding-docker-volumes-a-comprehensive-guide-46339aa9ac53](https://therahulsarkar.medium.com/understanding-docker-volumes-a-comprehensive-guide-46339aa9ac53)  
99. Guide to Docker Volumes | Baeldung on Ops, 8월 27, 2025에 액세스, [https://www.baeldung.com/ops/docker-volumes](https://www.baeldung.com/ops/docker-volumes)  
100. Volumes \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/engine/storage/volumes/](https://docs.docker.com/engine/storage/volumes/)  
101. Docker Volumes \- Guide with Examples \- Spacelift, 8월 27, 2025에 액세스, [https://spacelift.io/blog/docker-volumes](https://spacelift.io/blog/docker-volumes)  
102. Docker Networking \- Codecademy, 8월 27, 2025에 액세스, [https://www.codecademy.com/article/docker-networking](https://www.codecademy.com/article/docker-networking)  
103. Docker Networking Demystified: A Technical Guide with Examples | by Ravi Patel | Medium, 8월 27, 2025에 액세스, [https://medium.com/@ravipatel.it/docker-networking-demystified-a-technical-guide-with-examples-c4bfb94d870a](https://medium.com/@ravipatel.it/docker-networking-demystified-a-technical-guide-with-examples-c4bfb94d870a)  
104. Understanding Docker Networks: A Comprehensive Guide | Better Stack Community, 8월 27, 2025에 액세스, [https://betterstack.com/community/guides/scaling-docker/docker-networks/](https://betterstack.com/community/guides/scaling-docker/docker-networks/)  
105. Docker Networking \- Basics, Network Types & Examples \- Spacelift, 8월 27, 2025에 액세스, [https://spacelift.io/blog/docker-networking](https://spacelift.io/blog/docker-networking)  
106. Docker Networking – Basics, Network Types & Examples \- DEV Community, 8월 27, 2025에 액세스, [https://dev.to/tusharops\_29/docker-networking-basics-network-types-examples-5ed7](https://dev.to/tusharops_29/docker-networking-basics-network-types-examples-5ed7)  
107. Docker Networking \- GeeksforGeeks, 8월 27, 2025에 액세스, [https://www.geeksforgeeks.org/devops/basics-of-docker-networking/](https://www.geeksforgeeks.org/devops/basics-of-docker-networking/)  
108. Multi-container applications \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/get-started/docker-concepts/running-containers/multi-container-applications/](https://docs.docker.com/get-started/docker-concepts/running-containers/multi-container-applications/)  
109. Getting started with Docker-compose, a quick tutorial \- Geshan's Blog, 8월 27, 2025에 액세스, [https://geshan.com.np/blog/2024/04/docker-compose-tutorial/](https://geshan.com.np/blog/2024/04/docker-compose-tutorial/)  
110. Docker Compose \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/compose/](https://docs.docker.com/compose/)  
111. Part 7: Use Docker Compose \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/get-started/workshop/08\_using\_compose/](https://docs.docker.com/get-started/workshop/08_using_compose/)  
112. Docker Compose Tool To Run aMulti Container Applications \- GeeksforGeeks, 8월 27, 2025에 액세스, [https://www.geeksforgeeks.org/software-engineering/docker-compose-tool-to-run-multi-container-applications/](https://www.geeksforgeeks.org/software-engineering/docker-compose-tool-to-run-multi-container-applications/)  
113. Introduction to Docker Compose | Baeldung on Ops, 8월 27, 2025에 액세스, [https://www.baeldung.com/ops/docker-compose](https://www.baeldung.com/ops/docker-compose)  
114. A Deep Dive into Docker Compose \- DEV Community, 8월 27, 2025에 액세스, [https://dev.to/alexmercedcoder/a-deep-dive-into-docker-compose-27h5](https://dev.to/alexmercedcoder/a-deep-dive-into-docker-compose-27h5)  
115. Docker Compose YAML Explained: A Deep Dive into Configuration \- GeeksforGeeks, 8월 27, 2025에 액세스, [https://www.geeksforgeeks.org/devops/docker-compose-yaml-explained-a-deep-dive-into-configuration/](https://www.geeksforgeeks.org/devops/docker-compose-yaml-explained-a-deep-dive-into-configuration/)  
116. Docker Compose Quickstart \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/compose/gettingstarted/](https://docs.docker.com/compose/gettingstarted/)  
117. Docker Compose \- What is It, Example & Tutorial \- Spacelift, 8월 27, 2025에 액세스, [https://spacelift.io/blog/docker-compose](https://spacelift.io/blog/docker-compose)  
118. Docker Compose up, down, stop start difference \- GeeksforGeeks, 8월 27, 2025에 액세스, [https://www.geeksforgeeks.org/devops/docker-compose-up-down-stop-start-difference/](https://www.geeksforgeeks.org/devops/docker-compose-up-down-stop-start-difference/)  
119. docker compose up \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/reference/cli/docker/compose/up/](https://docs.docker.com/reference/cli/docker/compose/up/)  
120. docker compose down \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/reference/cli/docker/compose/down/](https://docs.docker.com/reference/cli/docker/compose/down/)  
121. docker-compose up, down, stop start difference \- Stack Overflow, 8월 27, 2025에 액세스, [https://stackoverflow.com/questions/46428420/docker-compose-up-down-stop-start-difference](https://stackoverflow.com/questions/46428420/docker-compose-up-down-stop-start-difference)  
122. How Compose works \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/compose/intro/compose-application-model/](https://docs.docker.com/compose/intro/compose-application-model/)  
123. Dockerignore: Ignore everything except a file and the Dockerfile \- Stack Overflow, 8월 27, 2025에 액세스, [https://stackoverflow.com/questions/28097064/dockerignore-ignore-everything-except-a-file-and-the-dockerfile](https://stackoverflow.com/questions/28097064/dockerignore-ignore-everything-except-a-file-and-the-dockerfile)  
124. How to use .dockerignore and its importance \- Shisho Cloud, 8월 27, 2025에 액세스, [https://shisho.dev/blog/posts/how-to-use-dockerignore/](https://shisho.dev/blog/posts/how-to-use-dockerignore/)  
125. Building best practices \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/build/building/best-practices/](https://docs.docker.com/build/building/best-practices/)  
126. 21 Docker Security Best Practices: Daemon, Image, Containers \- Spacelift, 8월 27, 2025에 액세스, [https://spacelift.io/blog/docker-security](https://spacelift.io/blog/docker-security)  
127. How to Build Smaller Container Images: Docker Multi-Stage Builds | iximiuz Labs, 8월 27, 2025에 액세스, [https://labs.iximiuz.com/tutorials/docker-multi-stage-builds](https://labs.iximiuz.com/tutorials/docker-multi-stage-builds)  
128. Docker multi-stage build explained | by Ahmad Al-Sajid \- Medium, 8월 27, 2025에 액세스, [https://ahmadalsajid.medium.com/docker-multi-stage-build-explained-f5ce86548e96](https://ahmadalsajid.medium.com/docker-multi-stage-build-explained-f5ce86548e96)  
129. Multi-stage builds | Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/get-started/docker-concepts/building-images/multi-stage-builds/](https://docs.docker.com/get-started/docker-concepts/building-images/multi-stage-builds/)  
130. Multi-Stage Docker Builds on CircleCI 2.0, 8월 27, 2025에 액세스, [https://circleci.com/blog/multi-stage-docker-builds/](https://circleci.com/blog/multi-stage-docker-builds/)  
131. Multi-stage builds \- Docker Docs, 8월 27, 2025에 액세스, [https://docs.docker.com/build/building/multi-stage/](https://docs.docker.com/build/building/multi-stage/)  
132. Top 20 Dockerfile best practices \- Sysdig, 8월 27, 2025에 액세스, [https://www.sysdig.com/learn-cloud-native/dockerfile-best-practices](https://www.sysdig.com/learn-cloud-native/dockerfile-best-practices)  
133. Docker Multi-stage Build: How to Make Your Docker Image Smaller | Cherry Servers, 8월 27, 2025에 액세스, [https://www.cherryservers.com/blog/docker-multistage-build](https://www.cherryservers.com/blog/docker-multistage-build)  
134. Six things to keep in mind when working with Dockerfiles : r/docker \- Reddit, 8월 27, 2025에 액세스, [https://www.reddit.com/r/docker/comments/gdfys3/six\_things\_to\_keep\_in\_mind\_when\_working\_with/](https://www.reddit.com/r/docker/comments/gdfys3/six_things_to_keep_in_mind_when_working_with/)  
135. Docker Security: 5 Risks and 5 Best Practices for Securing Your Containers \- Tigera, 8월 27, 2025에 액세스, [https://www.tigera.io/learn/guides/container-security-best-practices/docker-security/](https://www.tigera.io/learn/guides/container-security-best-practices/docker-security/)